<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="ekuL5J7xK1IdFtP13v3KxpuGKnYS1oCT9PvZdjYm8Eg">
  <meta name="baidu-site-verification" content="WrnmKQXx4O">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wxsm.space","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"tomorrow-night"},"prism":{"light":"prism-darcula","dark":"prism-darcula"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="https://cdn.bootcdn.net/ajax/libs/hexo-theme-next/8.25.0/config.min.js" defer></script>

    <meta name="description" content="关于 React Hooks 与 Vue Composite API：  React 16.8 新增了 Hooks API （简称 hooks) Vue 3.0 新增了 Composite API （简称 VCA）  二者为了共同的目的，在接近的时间点，以非常相似但是又带有本质区别的方式，推出了各自对于未来前端代码结构发展的新思路。本文在对二者做一些简单介绍的同时，也会重点关注二者之间的统一与区别">
<meta property="og:type" content="article">
<meta property="og:title" content="前端 MVC 的未来：浅谈 Hooks 与 VCA 在设计思路上的异同">
<meta property="og:url" content="https://wxsm.space/2021/react-hooks-vs-vca/index.html">
<meta property="og:site_name" content="wxsm&#39;s pace">
<meta property="og:description" content="关于 React Hooks 与 Vue Composite API：  React 16.8 新增了 Hooks API （简称 hooks) Vue 3.0 新增了 Composite API （简称 VCA）  二者为了共同的目的，在接近的时间点，以非常相似但是又带有本质区别的方式，推出了各自对于未来前端代码结构发展的新思路。本文在对二者做一些简单介绍的同时，也会重点关注二者之间的统一与区别">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wxsm.space/2021/react-hooks-vs-vca/vue-sfc.png">
<meta property="og:image" content="https://wxsm.space/2021/react-hooks-vs-vca/bench.png">
<meta property="og:image" content="https://wxsm.space/2021/react-hooks-vs-vca/cf7fa8cb-e185-4e49-b81a-297d402633cb.gif">
<meta property="og:image" content="https://wxsm.space/2021/react-hooks-vs-vca/35dff667-33ef-4403-86d4-ded321ea8bea.gif">
<meta property="og:image" content="https://wxsm.space/2021/react-hooks-vs-vca/b39cea16-d17f-4472-8fa4-671cd4a459c4.gif">
<meta property="og:image" content="https://wxsm.space/2021/react-hooks-vs-vca/2ab2c69e-41bf-458d-8d69-074ee188044e.gif">
<meta property="og:image" content="https://wxsm.space/2021/react-hooks-vs-vca/f9bafbe2-24f7-46bf-89a4-fee6aae5c33c.gif">
<meta property="og:image" content="https://wxsm.space/2021/react-hooks-vs-vca/f88339f0-a7f2-401b-a5b3-03de5cf75e3c.gif">
<meta property="og:image" content="https://wxsm.space/2021/react-hooks-vs-vca/f773cbbb-79bd-4920-8164-cdd998748c02.gif">
<meta property="article:published_time" content="2021-07-28T01:18:04.925Z">
<meta property="article:modified_time" content="2025-09-08T05:06:13.922Z">
<meta property="article:author" content="wxsm">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="vue">
<meta property="article:tag" content="react">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wxsm.space/2021/react-hooks-vs-vca/vue-sfc.png">


<link rel="canonical" href="https://wxsm.space/2021/react-hooks-vs-vca/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://wxsm.space/2021/react-hooks-vs-vca/","path":"2021/react-hooks-vs-vca/","title":"前端 MVC 的未来：浅谈 Hooks 与 VCA 在设计思路上的异同"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>前端 MVC 的未来：浅谈 Hooks 与 VCA 在设计思路上的异同 | wxsm's pace</title>
  
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-102731925-1","only_pageview":true,"measure_protocol_api_secret":null}</script>
  <script src="https://cdn.bootcdn.net/ajax/libs/hexo-theme-next/8.25.0/third-party/analytics/google-analytics.min.js" defer></script>








  
  <script src="https://cdn.bootcdn.net/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous" defer></script>
<script src="https://cdn.bootcdn.net/ajax/libs/hexo-theme-next/8.25.0/utils.min.js" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/hexo-theme-next/8.25.0/sidebar.min.js" defer></script><script src="https://cdn.bootcdn.net/ajax/libs/hexo-theme-next/8.25.0/next-boot.min.js" defer></script>

  <script src="https://cdn.bootcdn.net/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="https://cdn.bootcdn.net/ajax/libs/hexo-theme-next/8.25.0/third-party/search/local-search.min.js" defer></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.bootcdn.net/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="https://cdn.bootcdn.net/ajax/libs/hexo-theme-next/8.25.0/third-party/tags/mermaid.min.js" defer></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="https://cdn.bootcdn.net/ajax/libs/hexo-theme-next/8.25.0/third-party/math/mathjax.min.js" defer></script>


<link rel="dns-prefetch" href="https://blog-api.wxsm.space">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="wxsm's pace" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">wxsm's pace</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section">关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E8%AF%B4%E7%BB%93%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">先说结论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E5%90%8C%E7%9B%AE%E7%9A%84"><span class="nav-number">1.1.</span> <span class="nav-text">共同目的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 优化代码复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%87%8F%E8%BD%BB%E5%BF%83%E6%99%BA%E8%B4%9F%E6%8B%85"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 减轻心智负担</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B9%B2%E6%8E%89-this"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 干掉 this</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">本质区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF%E5%B7%AE%E5%BC%82"><span class="nav-number">2.</span> <span class="nav-text">常用场景差异</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.1.</span> <span class="nav-text">生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Mount-Unmount"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. Mount &#x2F; Unmount</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Update-Watch"><span class="nav-number">2.1.2.</span> <span class="nav-text">2. Update &#x2F; Watch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.</span> <span class="nav-text">变量定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">1. 变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. 方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text">代码复用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hook-%E5%BF%98%E8%AE%B0%E5%86%99-deps-%E5%AF%BC%E8%87%B4%E5%8F%98%E9%87%8F%E4%B8%8D%E6%9B%B4%E6%96%B0"><span class="nav-number">3.1.</span> <span class="nav-text">Hook: 忘记写 deps 导致变量不更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hook-Deps-%E5%86%99%E4%B8%8D%E5%A5%BD%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.2.</span> <span class="nav-text">Hook: Deps 写不好导致死循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%9C%A8-setState-%E7%9A%84%E5%90%8C%E6%97%B6%E5%8F%88%E4%BE%9D%E8%B5%96%E4%BA%86-state"><span class="nav-number">3.2.1.</span> <span class="nav-text">案例一：在 setState 的同时又依赖了 state</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A-useEffect-%E5%BF%98%E8%AE%B0%E5%86%99-deps"><span class="nav-number">3.2.2.</span> <span class="nav-text">案例二： useEffect 忘记写 deps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%B8%89%EF%BC%9Adeps-%E9%87%8C%E9%9D%A2%E5%A1%AB%E5%85%A5%E4%BA%86%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.3.</span> <span class="nav-text">案例三：deps 里面填入了直接定义的引用类型变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hooks-%E5%AE%9A%E4%B9%89%E4%BD%8D%E7%BD%AE%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text">Hooks: 定义位置的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VCA-%E8%A7%A3%E6%9E%84%E4%B8%A2%E5%A4%B1%E5%93%8D%E5%BA%94%E6%80%A7"><span class="nav-number">3.4.</span> <span class="nav-text">VCA: 解构丢失响应性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React-Hooks"><span class="nav-number">4.1.</span> <span class="nav-text">React Hooks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-Composite-API"><span class="nav-number">4.2.</span> <span class="nav-text">Vue Composite API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wxsm"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">wxsm</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">137</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wxsms" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wxsms" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/wxsm/" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;wxsm&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-steam fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/5771529/wxsm" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;5771529&#x2F;wxsm" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wxsms@foxmail.com" title="E-Mail → mailto:wxsms@foxmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.bootcdn.net/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://zexo.dev/" title="https:&#x2F;&#x2F;zexo.dev" rel="noopener" target="_blank">Aquariuslt blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://lz5z.com/" title="https:&#x2F;&#x2F;lz5z.com" rel="noopener" target="_blank">Lz's blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://coldstone.fun/" title="https:&#x2F;&#x2F;coldstone.fun&#x2F;" rel="noopener" target="_blank">冷石的博客</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wxsm.space/2021/react-hooks-vs-vca/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wxsm">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxsm's pace">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="前端 MVC 的未来：浅谈 Hooks 与 VCA 在设计思路上的异同 | wxsm's pace">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端 MVC 的未来：浅谈 Hooks 与 VCA 在设计思路上的异同
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-28 09:18:04" itemprop="dateCreated datePublished" datetime="2021-07-28T09:18:04+08:00">2021-07-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2021/react-hooks-vs-vca/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2021/react-hooks-vs-vca/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>关于 React Hooks 与 Vue Composite API：</p>
<ul>
<li>React 16.8 新增了 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-intro.html">Hooks API</a> （简称 hooks)</li>
<li>Vue 3.0 新增了 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">Composite API</a> （简称 VCA）</li>
</ul>
<p>二者为了共同的目的，在接近的时间点，以非常相似但是又带有本质区别的方式，推出了各自对于未来前端代码结构发展的新思路。本文在对二者做一些简单介绍的同时，也会重点关注二者之间的统一与区别。</p>
<span id="more"></span>

<h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><h3 id="共同目的"><a href="#共同目的" class="headerlink" title="共同目的"></a>共同目的</h3><h4 id="1-优化代码复用"><a href="#1-优化代码复用" class="headerlink" title="1. 优化代码复用"></a>1. 优化代码复用</h4><p>以下所说的代码复用，不包含组件复用等内容。两大框架老的复用方式存在的共同问题：</p>
<ul>
<li>变量、参数来源不明确（混乱）；</li>
<li>无命名空间，变量之间可能冲突、覆盖（不可靠）；</li>
</ul>
<p><strong>React</strong></p>
<ul>
<li>mixin</li>
</ul>
<p>因为 mixin 的缺点根本多到数不清，<a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-without-es6.html#mixins">React mixin</a> 是一种已经基本上被废弃了的写法。它在 class 组件中已经不可用了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">TickTock</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">    <span class="attr">mixins</span>: [<span class="title class_">SetIntervalMixin</span>], <span class="comment">// Use the mixin</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>HOC</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/higher-order-components.html">HOC</a> 是 Higher-Order Components 的简称。HOC 是通过语言自身的特性实现的，跟 React 本身没有关系。</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123; </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">BaseComp</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">text</span>=<span class="string">&#123;</span>&#x27;<span class="attr">someText</span>&#x27;&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HOC 是在 React Hooks 出现之前被广泛使用的代码复用方式，但是它存在自己的问题和局限性：</p>
<ol>
<li>不能在 <code>render</code> 函数内定义 HOC（会导致组件丢失状态，以及消耗性能）</li>
<li>高阶组件会丢失原组件的静态与实例方法，需要手动复制</li>
<li><code>ref</code> 将无法得到原始组件的引用，必须用 <code>React.forwardRef</code> 处理</li>
<li>复杂的高阶组件跟 mixin 一样，存在参数来源以及去向混乱的问题</li>
</ol>
<ul>
<li>继承（不支持生命周期钩子）</li>
</ul>
<p>继承这种方式，看起来很符合语言特性，但是 React 对它的支持是不完备的，甚至没有出现在官方推荐的方式里面。最主要的问题是，高阶组件没有办法复用基类的生命周期以及 render 函数，也不能通过形如 <code>super.componentDidMount()</code> 的形式来绕过这个问题。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BaseComp</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Vue</strong></p>
<ul>
<li>Mixin</li>
</ul>
<p>Vue 的 mixin 跟 React 非常类似，在提供便利的同时，同样带来了多到数不清的问题。摘录一下来自 Vue 官方文档的吐槽：</p>
<blockquote>
<p>在 Vue 2 中，mixin 是将部分组件逻辑抽象成可重用块的主要工具。但是，他们有几个问题：</p>
<ol>
<li><p>Mixin 很容易发生冲突：因为每个 mixin 的 property 都被合并到同一个组件中，所以为了避免 property 名冲突，你仍然需要了解其他每个特性。</p>
</li>
<li><p>可重用性是有限的：我们不能向 mixin 传递任何参数来改变它的逻辑，这降低了它们在抽象逻辑方面的灵活性。</p>
</li>
</ol>
</blockquote>
<ul>
<li>Directive</li>
</ul>
<p>Directive（指令）是一种特殊的代码复用，它的目的非常局限：操作 DOM 节点。也就是说，它的复用范围仅限于跟 DOM 操作相关的内容。</p>
<h4 id="2-减轻心智负担"><a href="#2-减轻心智负担" class="headerlink" title="2. 减轻心智负担"></a>2. 减轻心智负担</h4><p>在以<strong>职能</strong>来组织代码的时候，当我们的组件开始变得更大时，<strong>逻辑关注点</strong>的列表也会增长，举例（一张来自 Vue 文档的图片）：</p>
<p><img src="/2021/react-hooks-vs-vca/vue-sfc.png"></p>
<p>相信对于这类文件写过 Vue 的同学都深有体会。当我们需要查找跟某项功能相关的代码的时候，需要在文件中不停地搜索、上下跳动。非常难受。</p>
<h4 id="3-干掉-this"><a href="#3-干掉-this" class="headerlink" title="3. 干掉 this"></a>3. 干掉 <code>this</code></h4><p><code>this</code> 在 JavaScript 这个大环境下始终存在指向不明确的问题，无论是对初学者还是资深前端工程师来说也始终是一个需要特别注意的地方，同时也不利于静态分析和强类型检查。</p>
<h3 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h3><p>二者的区别，说来非常简单，但是又非常巨大：</p>
<ol>
<li>React Hooks 是 <strong>effect</strong> (副作用)，在组件<strong>每次渲染的时候都会执行</strong></li>
<li>VCA 是 <strong>setup</strong> (安装&#x2F;配置)，仅在组件初始化的时候<strong>执行一次</strong></li>
</ol>
<p>这些区别是由框架本身的特性决定的，而它们具体代表了什么，需要在下文继续阐释。</p>
<h2 id="常用场景差异"><a href="#常用场景差异" class="headerlink" title="常用场景差异"></a>常用场景差异</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Hooks 移除了生命周期的概念，取而代之的是 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-effect.html">effect</a> ，VCA 则近乎完整地保留了生命周期概念与函数。</p>
<h4 id="1-Mount-Unmount"><a href="#1-Mount-Unmount" class="headerlink" title="1. Mount &#x2F; Unmount"></a>1. Mount &#x2F; Unmount</h4><p><strong>hooks</strong></p>
<p>React Hooks 摒弃了 mount &#x2F; unmount &#x2F; update 等生命周期概念，转而引入了一个新的 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-effect.html">useEffect</a> 函数，简而言之：</p>
<ol>
<li><code>useEffect</code> 接收两个参数，第一个是回调函数 <code>callback</code>，第二个是数组 <code>deps</code></li>
<li><code>callback</code> 可以没有返回值，也可以返回一个函数，如果返回了函数，那将会是这个 effect 的「清除」函数</li>
<li>当组件初次挂载，或者每当 <code>deps</code> 里面的任意一个元素发生变化的时候（这个时机由 React 判断），回调函数将会被执行一次</li>
<li>特殊情况：<ol>
<li><code>deps</code> 未传：<code>callback</code> 在每次渲染的时候都会执行一次</li>
<li><code>deps</code> 为空数组：<code>callback</code> 当且仅当组件第一次挂载的时候执行一次</li>
</ol>
</li>
</ol>
<p>因此，可以使用 <code>useEffect</code> 同时模拟 mount 与 unmount 事件：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// componentDidMount (mounted)</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[componentDidMount]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">clicked</span> = (<span class="params">e: MouseEvent</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setXy</span>([e.<span class="property">clientX</span>, e.<span class="property">clientY</span>])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, clicked)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// componentWillUnmount (beforeUnmount)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[componentWillUnmount]&#x27;</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, clicked)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p>这样做有几个好处：</p>
<ol>
<li>对于通常需要成对出现的，类似注册、解注册的逻辑来说，这么做可以使得逻辑更加内聚</li>
<li>挂载和卸载函数可以读取到同一个作用域下的变量和方法，就比如以上例子中的 <code>clicked</code> 事件</li>
</ol>
<p>但是，由此也带来了一个显而易见的问题：<code>callback</code> 没法使用 <code>async</code> 函数了。因为 <code>async</code> 函数必定会返回一个 <code>Promise</code> 实例，而这明显与设计相悖。想要在 <code>useEffect</code> 内部使用 <code>async</code> 函数的话，做法会有点绕：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>vca</strong></p>
<p>与 Hooks 大相庭径：</p>
<ol>
<li>VCA 保留了传统的 mounted 与 unmount 事件，只不过换了个形式</li>
<li>VCA 不需要写 <code>deps</code></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> xy = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">clicked</span> = (<span class="params">e: MouseEvent</span>) =&gt; &#123;</span><br><span class="line">      xy.<span class="property">x</span> = e.<span class="property">clientX</span></span><br><span class="line">      xy.<span class="property">y</span> = e.<span class="property">clientY</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, clicked)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, clicked)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;xy&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-Update-Watch"><a href="#2-Update-Watch" class="headerlink" title="2. Update &#x2F; Watch"></a>2. Update &#x2F; Watch</h4><p><strong>hooks</strong></p>
<p>当 <code>useEffect</code> 的 <code>deps</code> 不为空时，回调函数在组件第一次挂载时，以及后续每次 <code>deps</code> 的其中之一变化时都会执行。</p>
<p>这里有一点需要注意的是：**除 <code>useRef</code> 以及 <code>useState</code> 的 setter 以外，其它所有回调函数中用到的变量，都需要写进 <code>deps</code>**，包括 <code>state</code> &#x2F; <code>memo</code> &#x2F; <code>callback</code> 等，否则（因为闭包的存在）函数调用时永远会拿到旧的值。</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// componentDidUpdate (watch / updated)</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[componentDidUpdate]&#x27;</span>, xy)</span><br><span class="line">&#125;, [xy])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误！fetchData 也需要写进 deps</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// useRef</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(countRef.<span class="property">current</span>)</span><br><span class="line">  <span class="comment">// useCallback useState</span></span><br><span class="line">  <span class="title function_">fetchData</span>(page)</span><br><span class="line">&#125;, [page])</span><br></pre></td></tr></table></figure>

<p><strong>vca</strong></p>
<p>VCA 的 updated 与 watch 与原 API 也基本类似，但是有几个需要注意的点：</p>
<ol>
<li>增加了一个新的概念 <code>watchEffect</code>，与 <code>useEffect</code> 十分类似，但是不需要写 <code>deps</code>！</li>
<li><code>watch</code> 与 <code>watchEffect</code> 都<strong>不能</strong>直接监听 <code>reactive</code> 本身——因为只有 reactive 下面的属性才是真正意义上的 reactive</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;updated&#x27;</span>, xy)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> xy.<span class="property">y</span>, <span class="function">(<span class="params">y, oy</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watch&#x27;</span>,y, oy)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，两个参数都将是更新后的值</span></span><br><span class="line"><span class="title function_">watch</span>(xy, <span class="function">(<span class="params">y, oy</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watch&#x27;</span>,y, oy)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect&#x27;</span>, xy.<span class="property">y</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，无法触发</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect&#x27;</span>, xy)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>总体区别：</p>
<ul>
<li>从利于维护的角度出发，hooks 内原则上不允许直接定义任何变量，包括常量、方法等，因为<strong>组件每次渲染时都会重新初始化</strong>。因此从某种意义上来说，直接定义的变量也是一种响应式变量（当能够正确赋予初始值的时候）。</li>
<li>VCA 无此限制。并且直接定义的变量为常量。</li>
</ul>
<p>注：关于第一点，社区一直存在争议。争议的关键点在于每次渲染都重新初始化变量到底会不会对性能造成压力。<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render">官方文档</a> 的说法是<strong>不会</strong>，但是从目前的 benchmark 结果来看，React Hooks 确实已经处于下风了（当然这里面也会有其它方面的影响因素）：</p>
<p><img src="/2021/react-hooks-vs-vca/bench.png"></p>
<h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h4><p><strong>hooks</strong></p>
<p>hooks 大致提供了以下几种定义变量的方法：</p>
<ul>
<li><code>useState</code>: 响应式变量，不需要 <code>deps</code></li>
<li><code>useMemo</code>: 常量（不可变）或计算值，需要写 <code>deps</code></li>
<li><code>useRef</code>: 变量（可改变，但不影响渲染），不需要 <code>deps</code></li>
<li>直接定义: 通常来说是错误的写法</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// state， 影响渲染</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算属性，count 发生变化时会改变，影响渲染</span></span><br><span class="line"><span class="keyword">const</span> doubleCount = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> count * <span class="number">2</span>, [count])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量，但不影响渲染</span></span><br><span class="line"><span class="keyword">const</span> doubleCountRef = <span class="title function_">useRef</span>(count * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接定义，每次渲染时都会重新计算值，因此也能影响渲染</span></span><br><span class="line"><span class="keyword">const</span> renderEveryTime = count * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/react-hooks-vs-vca/cf7fa8cb-e185-4e49-b81a-297d402633cb.gif"></p>
<p><strong>vca</strong></p>
<p>VCA 提供了以下几种定义变量的方法：</p>
<ul>
<li><code>ref</code>: 包裹（深度）响应式对象。之所以存在，是因为基础类型目前来说无法做到响应式，所以必须通过一个对象来包裹，通过 <code>xxx.value</code> 访问基础类型才能获得响应式。同时允许 object&#x2F;array 的重新赋值。</li>
<li><code>reactive</code>: 与 ref 实现的效果一样，区别是不需要通过 <code>.value</code> 即可访问，同时也不能被重新赋值。</li>
<li><code>computed</code>: 计算值</li>
<li>直接定义: 常量</li>
</ul>
<p>无论哪种方式，VCA 都不需要写 deps</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// state， 影响渲染</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算属性，count 发生变化时会改变，影响渲染</span></span><br><span class="line"><span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量，一次性的值，不影响渲染</span></span><br><span class="line"><span class="keyword">const</span> doubleCountRef = count.<span class="property">value</span> * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/react-hooks-vs-vca/35dff667-33ef-4403-86d4-ded321ea8bea.gif"></p>
<h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h4><p><strong>hooks</strong></p>
<ul>
<li>从利于维护的角度出发，方法定义需要使用 <code>useCallback</code> 包裹，某则每次渲染都会被重新创建，并且当方法作为 PureComponent 子组件的参数使用时会触发子组件的重新渲染。</li>
<li>方法必须正确定义 <code>deps</code>，否则内部取值将得不到变化后的值</li>
<li>方法的 <code>deps</code> 一旦改变，方法将会被重新创建，闭包也会得到更新</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> addCount = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">v</span> =&gt;</span> ++v)</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> addCount = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">&#125;, [count])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误, 永远相当于 setCount(0 + 1)</span></span><br><span class="line"><span class="keyword">const</span> addCount = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p><strong>vca</strong></p>
<p>没什么限制，可以随心所欲。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addCount = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  ++count.<span class="property">value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h3><p>二者在代码复用这一块的理念十分类似，最终体现在代码上就像是两兄弟。</p>
<p><strong>hooks</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState, memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMousePosition</span> () &#123;</span><br><span class="line">  <span class="keyword">const</span> [xy, setXy] = <span class="title function_">useState</span>([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">moved</span> = (<span class="params">e: MouseEvent</span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">setXy</span>([e.<span class="property">clientX</span>, e.<span class="property">clientY</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, moved)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, moved)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: xy[<span class="number">0</span>],</span><br><span class="line">    <span class="attr">y</span>: xy[<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMousePosition</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>CustomHooks<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>Mouse Position: &#123;x&#125;,&#123;y&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/react-hooks-vs-vca/b39cea16-d17f-4472-8fa4-671cd4a459c4.gif"></p>
<p><strong>vca</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useMousePosition</span> () &#123;</span><br><span class="line">  <span class="keyword">const</span> xy = <span class="title function_">reactive</span>(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">moved</span> = (<span class="params">e: MouseEvent</span>) =&gt; &#123;</span><br><span class="line">    xy.<span class="property">x</span> = e.<span class="property">clientX</span></span><br><span class="line">    xy.<span class="property">y</span> = e.<span class="property">clientY</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, moved)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, moved)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> xy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> xy = <span class="title function_">useMousePosition</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; xy &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/react-hooks-vs-vca/2ab2c69e-41bf-458d-8d69-074ee188044e.gif"></p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>简单来说，由于两个框架各自的特性，问题也通常来自于：</p>
<ol>
<li>deps (hook)</li>
<li>Proxy (VCA)</li>
</ol>
<p>不过有一个好消息是，React 提供了一个插件 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a> 可以帮忙检测 deps 的缺失，并且后续有计划通过代码静态分析去除掉这个烦人的依赖项。</p>
<h3 id="Hook-忘记写-deps-导致变量不更新"><a href="#Hook-忘记写-deps-导致变量不更新" class="headerlink" title="Hook: 忘记写 deps 导致变量不更新"></a>Hook: 忘记写 deps 导致变量不更新</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// state</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// method</span></span><br><span class="line"><span class="keyword">const</span> addCount = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p><img src="/2021/react-hooks-vs-vca/f9bafbe2-24f7-46bf-89a4-fee6aae5c33c.gif"></p>
<h3 id="Hook-Deps-写不好导致死循环"><a href="#Hook-Deps-写不好导致死循环" class="headerlink" title="Hook: Deps 写不好导致死循环"></a>Hook: Deps 写不好导致死循环</h3><h4 id="案例一：在-setState-的同时又依赖了-state"><a href="#案例一：在-setState-的同时又依赖了-state" class="headerlink" title="案例一：在 setState 的同时又依赖了 state"></a>案例一：在 setState 的同时又依赖了 state</h4><p>常见于列表加载：</p>
<ol>
<li>首页数据可以直接 <code>setState</code></li>
<li>后续分页的数据要在现有基础上追加</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addCount = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">&#125;, [count])</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">addCount</span>()</span><br><span class="line">&#125;, [addCount])</span><br></pre></td></tr></table></figure>

<p><img src="/2021/react-hooks-vs-vca/f88339f0-a7f2-401b-a5b3-03de5cf75e3c.gif"></p>
<h4 id="案例二：-useEffect-忘记写-deps"><a href="#案例二：-useEffect-忘记写-deps" class="headerlink" title="案例二： useEffect 忘记写 deps"></a>案例二： useEffect 忘记写 deps</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addCount = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">1</span>)</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">addCount</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="案例三：deps-里面填入了直接定义的引用类型变量"><a href="#案例三：deps-里面填入了直接定义的引用类型变量" class="headerlink" title="案例三：deps 里面填入了直接定义的引用类型变量"></a>案例三：deps 里面填入了直接定义的引用类型变量</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue = []</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 someValue 每次渲染时都会重新初始化，</span></span><br><span class="line"><span class="comment">// 而引用类型重新初始化后其地址是不等的，</span></span><br><span class="line"><span class="comment">// 因此会触发死循环</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">setCount</span>(<span class="function"><span class="params">v</span> =&gt;</span> ++v)</span><br><span class="line">&#125;, [someValue])</span><br></pre></td></tr></table></figure>

<h3 id="Hooks-定义位置的限制"><a href="#Hooks-定义位置的限制" class="headerlink" title="Hooks: 定义位置的限制"></a>Hooks: 定义位置的限制</h3><p>因为 Hooks 的实现原理是链表，必须保证每次组件渲染得到的 hooks 及其顺序都是一致的，因此使用 Hook 需要遵循两条额外的规则：</p>
<ul>
<li>只能在 React 函数中调用 Hook，不能在普通的 JavaScript 函数中调用；</li>
<li>不能在循环，条件或嵌套函数中调用 Hook</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法，会直接报错</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [double, doubleCount] = <span class="title function_">useState</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VCA-解构丢失响应性"><a href="#VCA-解构丢失响应性" class="headerlink" title="VCA: 解构丢失响应性"></a>VCA: 解构丢失响应性</h3><p>包括 <code>props</code> &#x2F; <code>reactive</code> 在内的所有 Proxy 类型变量都不能解构，否则会丢失响应性。解构必须使用 <code>toRefs</code> 方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">reactive</span>(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> addCount = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      ++count.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; count, value, addCount &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/react-hooks-vs-vca/f773cbbb-79bd-4920-8164-cdd998748c02.gif"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h3><p>优点：</p>
<ul>
<li>目前为止最好的代码复用方式（之一）</li>
<li>优秀且精炼的设计理念</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要写 <code>deps</code></li>
<li>由于其每次渲染都执行 (effect) 的特点，目前被业界公认为心智负担极重</li>
</ul>
<h3 id="Vue-Composite-API"><a href="#Vue-Composite-API" class="headerlink" title="Vue Composite API"></a>Vue Composite API</h3><p>优点：</p>
<ul>
<li>目前为止最好的代码复用方式（之一）</li>
<li>作为 setup，上手难度相较 hooks 可谓是极低，心智负担极低</li>
</ul>
<p>缺点：</p>
<ul>
<li>与 Hooks 相比，API 设计（也许）不够精炼，受制于历史包袱</li>
<li>Proxy 虽然带来了便利，但是也带来了麻烦，经常需要考虑：<ul>
<li>一个对象能否解构？</li>
<li>一个属性到底应该用 <code>ref</code> 还是 <code>reactive</code>？</li>
<li>取值的时候要不要加 <code>.value</code>（常常被忘记）？</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-intro.html">React Hooks 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">Vue Composite API 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/133819602">知乎：Vue3 究竟好在哪里？（和 React Hook 的详细对比）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/390974405">知乎：新版react中，useCallback 和 useMemo 是不是值得大量使用？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.vuejs.org/posts/vue-3.2.html">Vue 3.2 Released!</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="wxsm 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="wxsm 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>wxsm
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://wxsm.space/2021/react-hooks-vs-vca/" title="前端 MVC 的未来：浅谈 Hooks 与 VCA 在设计思路上的异同">https://wxsm.space/2021/react-hooks-vs-vca/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"># javascript</a>
              <a href="/tags/vue/" rel="tag"># vue</a>
              <a href="/tags/react/" rel="tag"># react</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/a-simple-way-to-speed-up-github-connection/" rel="prev" title="比较简单的 GitHub 加速方式">
                  <i class="fa fa-angle-left"></i> 比较简单的 GitHub 加速方式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/paste-image-into-markdown-in-jetbrains-ide/" rel="next" title="在 JetBrains IDE 中向 Markdown 粘贴图片">
                  在 JetBrains IDE 中向 Markdown 粘贴图片 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wxsm</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://blog-api.wxsm.space","cssUrl":"https://cdn.bootcdn.net/ajax/libs/waline/2.15.1/waline.min.css","commentCount":true,"pageview":false,"avatar":"retro","pageSize":10,"visitor":false,"comment_count":false,"requiredFields":[],"libUrl":"https://cdn.bootcdn.net/ajax/libs/waline/2.15.1/waline.min.js","uploadImage":false,"copyright":true,"dark":"auto","el":"#waline","comment":true,"path":"/2021/react-hooks-vs-vca/"}</script>
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/waline/2.15.1/waline.min.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
