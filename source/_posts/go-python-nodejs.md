---
title: Go，Python 与 Nodejs
date: 2023-09-08 22:34:22
tags: [nodejs,python,go] 
---

最近除了在写 Go 程序以外，Python 也写了不少。其实我之前也写了不少 Python 程序，但是并没怎么深入学习过。这次工作要用到了，就认真地找了一门课学了学。加上频繁地在两种语言之间切换，再加上做前端几年接触过的 Node.js，也发现一些挺有意思的点。这篇文章就当作是一个来自后端新手的记录。

<!-- more -->

## 多线程与抢占

### 单线程的 Node.js

初学 Node.js 还是刚毕业的时候，那时候我感觉后端好简单。不过就是写写业务代码，写写 CRUD，学校老师也没怎么教多线程方面的知识。至于 Event Loop，Callback hell 什么的，也只是似懂非懂。以至于后面写了好多年的 Node.js，依然觉得后端好简单。本质上来说用 Node.js 写后端的体验跟写前端是差不多的，也就是心智模型有一些区别。

但是在写了一段时间的 Go 以后，我才发现原来 Node.js 真的好简单。字面意义上的简单。Node.js 为什么简单，因为它（js 线程）是单线程的。单线程它就不涉及抢占，全靠事件循环+异步 IO。在 Node.js 里面定义的变量，无论怎样都不会出现抢占。这点跟写前端 JS 时也是一样的。就好比，我们虽然可以通过 setTimeout 之类的函数来实现一个异步操作，但是它本质上还是在同一个线程上运行，只不过事件调度器会按照某种规则来完成调度（主线程、宏任务、微任务...）。意识到这一点后我终于发现了 Node.js 的牛逼之处：仅凭一条线程就可以进行如此高效的 IO 处理，以至于当年替代 Java 的呼声不绝于耳。

（后来学了 Redis 以后，我发现 Redis 的主要功能其实也是单线程实现的。**没有抢占**也许就是单线程最大的优势。）

### 多线程的 Go

今年写了一段时间 Golang 以后，我发现问题变得复杂起来了：Go 程序是纯正的多线程程序。多线程的心智模型与单线程完全不一样且相当复杂，究其本质在于多线程会出现抢占：线程 A 正在读内存的时候，线程 B 可能正在写同一块内存，因此 A 可能会读到写了一半的内存。

为了解决多线程的问题，就需要引入“锁”的概念来将不同线程之间的读写操作隔离开：同一时间、同一内存块只能有一个线程在执行操作。但是如果是这么简单粗暴的解决方式，多线程不就退化成单线程了吗（甚至可能还不如，因为线程切换也要消耗资源）？因此 Go 提供了两种锁：互斥锁（Mutex）和读写锁（RWMutex）。其中读写锁对读写场景做了优化：多个读之间可以并发进行，但是读与写、写与写不能并发进行。

优化到这里就结束了吗？远远没有。事实上 Go 一直在对锁进行迭代优化，比如读写锁可能会出现的写“饥饿”问题：大量的读操作源源不断地涌入，导致写操作可能永远无法获取到锁。许许多多诸如此类的问题导致多线程从一开始就注定是复杂的。

平时在写 Go 程序的时候，时时刻刻都要关注多线程带来的问题：这个变量会不会被其它协程读写？会不会出现抢占？如果会出现抢占，应该用什么方式来解决（互斥锁？读写锁？原子操作？Channel？）？导致我这个新人觉得 Go 语言（或者说真正意义上的服务端开发）的心智模型相当复杂。

### 奇葩的 Python

我为什么说 Python 是一朵奇葩？因为它：即是事实上的单线程，并且还会出现抢占。